name: Alarms - Plan/Apply

on:
  workflow_dispatch:
    inputs:
      environment:
        description: "Terraform workspace (예: dev, staging, prod)"
        required: false
        default: "dev"
      mode:
        description: "실행 모드 (plan | apply)"
        required: true
        type: choice
        options: [plan, apply]
  push:
    branches: [ main ]
    paths:
      - "Endpoint_Infra/modules/alarms/**"
      - "Endpoint_Infra/main.tf"
      - "Endpoint_Infra/variables.tf"
      - "Endpoint_Infra/outputs.tf"
  workflow_call:                      
    inputs:
      environment:
        required: false
        type: string
        default: "dev"
      mode:
        required: true
        type: string

permissions:
  id-token: write
  contents: read

concurrency:
  group: alarms-${{ github.ref }}
  cancel-in-progress: false

jobs:
  run:
    runs-on: ubuntu-latest
    env:
      TF_IN_AUTOMATION: true
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false

      - name: Terraform init (shared backend)
        working-directory: Endpoint_Infra
        run: terraform init -input=false -reconfigure -backend-config="${{ github.workspace }}/.github/terraform/backend.hcl"

      - name: Select workspace
        working-directory: Endpoint_Infra
        run: |
          terraform workspace select "${{ inputs.environment }}" || terraform workspace new "${{ inputs.environment }}"
      
      - name: Decide monitor envs by checking endpoint existence
        id: decide
        shell: bash
        run: |
          set -Eeuo pipefail
          WS="${{ inputs.environment || 'dev' }}"
          ENVS="[]"

          case "$WS" in
            staging) EP="${{ vars.ENDPOINT_STAGING }}" ;;
            prod)    EP="${{ vars.ENDPOINT_PROD }}" ;;
          *)       EP="" ;;
          esac

          if [ -n "$EP" ]; then
            if aws sagemaker describe-endpoint --endpoint-name "$EP" >/dev/null 2>&1; then
              ENVS="[\"$WS\"]"
              echo "Endpoint '$EP' exists. Enabling monitor for $WS."
            else
              echo "Endpoint '$EP' not found. Skipping monitor for $WS."
            fi
          else
            echo "No endpoint variable mapped for workspace '$WS'."
          fi

          echo "monitor_envs=$ENVS" >> $GITHUB_OUTPUT

      - name: Terraform plan
        if: ${{ inputs.mode == 'plan' }}
        working-directory: Endpoint_Infra
        env:
          TF_VAR_enable_monitor_envs: ${{ steps.decide.outputs.monitor_envs }}
        run: terraform plan -no-color -input=false -var-file="env/${{ inputs.environment }}.tfvars"

      - name: Terraform apply
        if: ${{ inputs.mode == 'apply' }}
        working-directory: Endpoint_Infra
        env:
          TF_VAR_enable_monitor_envs: ${{ steps.decide.outputs.monitor_envs }}
        run: terraform apply -auto-approve -no-color -input=false -var-file="env/${{ inputs.environment }}.tfvars"

      - name: Read alarm outputs (JSON)
        if: ${{ inputs.mode == 'apply' }}
        id: tfout
        working-directory: Endpoint_Infra
        run: |
          set -Eeuo pipefail
          OUT_JSON="$(terraform output -json 2>/dev/null || true)"
          echo "$OUT_JSON" > alarm_outputs.json
          echo "WROTE alarm_outputs.json"

      - name: Upload outputs artifact
        if: ${{ inputs.mode == 'apply' }}
        uses: actions/upload-artifact@v4
        with:
          name: alarm-outputs
          path: infra/alarm_outputs.json

